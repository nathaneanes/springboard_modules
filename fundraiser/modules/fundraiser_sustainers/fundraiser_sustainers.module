<?php

/**
 * @file
 * Sustainer page callbacks for the fundraiser module.
 *
 * Why? Footprint again. Not all sites need recurring / sustainer maintained fundraising.
 * (Use this module to model behavior and actions for peer-to-peer and other fundraiser types.)
 */

require_once 'includes/fundraiser_sustainers.goals.inc';

/**
 * Implements hook_cron().
 */
function fundraiser_sustainers_cron() {
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    return 0;
  }
  else {
    watchdog('fundraiser_cron', 'Standard cron run.', NULL, WATCHDOG_INFO);
    fundraiser_sustainers_standalone_cron();
  }
}

/**
 * Implements hook_permission().
 */
function fundraiser_sustainers_permission() {
  return array(
    'cancel future donations' => array(
      'title' => t('Cancel future donations'),
      'description' => t('Cancel future donations.'),
    ),
    'administrate recurring donations' => array(
      'title' => t('Administrate recurring donations'),
      'description' => t('Administrate recurring donations.'),
    ),
    'fastforward recurring donations' => array(
      'title' => t('Fastforward recurring donations'),
      'description' => t('Fastforward recurring donations.'),
    ),
    'set new recurring charge date' => array(
      'title' => t('Set new recurring charge date'),
      'description' => t('Specify a new charge date for future recurring donations.'),
    ),
    'skip recurring donations' => array(
      'title' => t('Skip recurring donation'),
      'description' => t('Cancel a single recurring donation.'),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function fundraiser_sustainers_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'fundraiser_sustainers') . '/includes',
  );
}

/**
 * Implements hook_menu().
 */
function fundraiser_sustainers_menu() {
  // Add the cron handler if it's enabled.
  $items['fundraiser_cron'] = array(
    'page callback' => 'fundraiser_sustainers_standalone_cron',
    'access callback' => 'fundraiser_sustainers_standalone_cron_access',
    'type' => MENU_CALLBACK,
  );
  // User interface.
  $items['user/%user/recurring_overview'] = array(
    'title' => 'My recurring donations',
    'page callback' => 'fundraiser_sustainers_user_overview',
    'page arguments' => array(1),
    'access callback' => 'user_edit_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  $items['fundraiser_sustainers/ffwd/%'] = array(
    'title' => 'Charge recurring donation now',
    'page callback' => 'fundraiser_sustainers_charge_now',
    'page arguments' => array(2),
    'access arguments' => array('fastforward recurring donations'),
    'type' => MENU_CALLBACK,
  );
  $items['fundraiser_sustainers/%/skip/%'] = array(
    'title' => 'Skip recurring donation',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_sustainers_skip', 1, 3),
    'access arguments' => array('skip recurring donations'),
    'type' => MENU_CALLBACK,
  );
  // Admin interface.
  $items['admin/config/system/fundraiser/recurring'] = array(
    'title' => 'Recurring donations',
    'page callback' => 'fundraiser_sustainers_admin',
    'access arguments' => array('administrate recurring donations'),
    'file' => 'fundraiser_sustainers.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/system/fundraiser/recurring/%'] = array(
    'title' => 'View donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_CALLBACK,
    'tab_parent' => 'admin/config/system/fundraiser/recurring',
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/view'] = array(
    'title' => 'View donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/edit'] = array(
    'title' => 'Edit donation',
    'page callback' => 'fundraiser_sustainers_admin_edit',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  // If Ubercart exists. Show these as a tab there as well.
  if (module_exists('uc_order')) {
    $items['admin/store/orders/%/recurring'] = array(
      'title' => 'Recurring donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/recurring'] = array(
      'title' => 'View donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/edit'] = array(
      'title' => 'Edit donation set',
      'page callback' => 'fundraiser_sustainers_admin_edit',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'file' => 'fundraiser_sustainers.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
  }
  // If Commerce exists. Show these as a tab there as well.
  if (module_exists('commerce')) {
    $items['admin/commerce/orders/%/recurring'] = array(
      'title' => 'Recurring donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/commerce/orders/%/recurring/recurring'] = array(
      'title' => 'View donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/commerce/orders/%/recurring/edit'] = array(
      'title' => 'Edit donation set',
      'page callback' => 'fundraiser_sustainers_admin_edit',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'file' => 'fundraiser_sustainers.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
  }
  return $items;
}

/**
 * Implements hook_springboard_admin_alias_patterns().
 */
function fundraiser_sustainers_springboard_admin_alias_patterns() {
  return array(
    // Fundraiser sustainers skip payment confirmation page.
    'fundraiser_sustainers/%did/skip/%cid' => array(
      'path' => array(
        'regex' => '|^/fundraiser_sustainers/([0-9]+)/skip/([0-9]+)$|',
        'replacement' => 'fundraiser_sustainers/$1/skip/$2',
      ),
      'alias' => array(
        'regex' => '|^springboard/donations/([0-9]+)/skip/([0-9]+)$|',
        'replacement' => 'springboard/donations/$1/skip/$2',
      ),
    ),
  );
}

/**
 * Access callback for running standalone cron.
 */
function fundraiser_sustainers_standalone_cron_access() {
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Menu access callback, check if the order has recurring orders (as master id).
 */
function fundraiser_sustainers_check_access($did) {
  // First check if this even has a recurring donation.
  $donations = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  if (!$donations) {
    return FALSE;
  }
  // Then check if the user is allowed.
  return user_access('administrate recurring donations');
}

/**
 * Menu callback function, determines if a user has any recurring donations.
 */
function _fundraiser_sustainers_user_has_recurring_donations($user) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Menu callback for the standalone cron.
 */
function fundraiser_sustainers_standalone_cron() {
  // Process recurring donations.
  $process_recurring = TRUE;
  $processor_key_match = fundraiser_sustainers_processor_key_match();
  drupal_alter('fundraiser_sustainers_process_recurring', $process_recurring);

  if ($process_recurring && $processor_key_match) {
    fundraiser_sustainers_process_recurring_donations();
  }
  if (!$process_recurring) {
    $message = t('Standalone sustainer processing has been disabled by another module.');
    drupal_set_message($message);
  }
  if (!$processor_key_match) {
    $message = t('The fundraiser sustainer key has not been configured correctly. Recurring donations will not be processed.');
    drupal_set_message($message, 'warning');
    watchdog('fundraiser_cron', $message, NULL, WATCHDOG_CRITICAL);
  }
}

/**
 * Menu callback to ffwd a charge (for testers).
 */
function fundraiser_sustainers_charge_now($did) {
  // Given a did, update the charge date to now.
  $donation = new stdClass();
  $donation->did = $did;
  $donation->next_charge = strtotime('now');
  _fundraiser_sustainers_update_recurring($donation);
  drupal_set_message(t('The charge date for donation #@did has been advanced to @date. It will be charged on the next Fundraiser cron.',
    array('@did' => $did, '@date' => format_date(strtotime('now')))));
  // Afterwards return where we came from.
  drupal_goto( drupal_get_destination() );
}

/**
 * Menu callback to skip a charge .
 */

function fundraiser_sustainers_skip($form, &$form_state, $master_did, $did) {
  $form['did'] = array(
    '#type' => 'value',
    '#value' => $did,
  );
  return confirm_form($form, t('Are you sure you want to skip this recurring donation'), 'admin/commerce/orders/' . $master_did . '/recurring/edit', t('This action cannot be undone.'), t('YES'), t('NO'));
}

function fundraiser_sustainers_skip_submit($form, &$form_state) {
  // Given a did, update the charge date to now.
  $donation = fundraiser_donation_get_donation($form_state['values']['did']);
  fundraiser_donation_cancel($donation);
  $donation->donation_skipped = TRUE;

  _fundraiser_commerce_update_order_status('skipped', $donation->did);
  $donation->status = 'skipped';
  $donation->status_label = _fundraiser_commerce_get_label_by_status('skipped');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('skipped');
  fundraiser_donation_update($donation);

  db_query('UPDATE {fundraiser_sustainers} SET ' .
    'gateway_resp = \'skipped\',' .
    'lock_id = 0, ' .
    'cancellation_reason = \'skipped by admin\' ' .
    'WHERE did = :did', array(':did' => $donation->did)
  );

  if (module_exists('salesforce_genmap')) {
    salesforce_genmap_send_object_to_queue('salesforce_donation', 'update', $donation->node, $donation->did, $donation, 'donation');
  }
  drupal_set_message(t('The recurring donation has been cancelled.'));
  // Afterwards return where we came from.
  drupal_goto( drupal_get_destination() );
}

/**
 * Implements hook_tokens_alter().
 */
function fundraiser_sustainers_tokens_alter(&$replacements, $context) {
  $type = $context['type'];
  $tokens = $context['tokens'];
  $data = $context['data'];
  $options = $context['options'];
  if ($type = 'donation' && !empty($data['donation'])) {
    $donation = $data['donation'];
    $replacements['[donation:recurs_monthly]'] = t('No');
    if (!empty($donation->donation['recurs_monthly']) && $donation->donation['recurs_monthly']) {
      $replacements['[donation:recurs_monthly]'] = t('Yes');
    }
  }
}

/**
 * Implements hook_mail().
 */
function fundraiser_sustainers_mail($key, &$message, $params) {
  switch ($key) {
    case 'fundraiser_cc_notification':
      $message['subject'] = variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire');
      $message['body'][] = $params['fundraiser_sustainers_body'];
      break;
  }
}

/**
 * Salesforce hooks and integrations.
 */

/**
 * Implements hook_salesforce_genmap_map_fields().
 */
function fundraiser_sustainers_salesforce_genmap_map_fields(stdClass $donation, Entity $map, $node, $op) {
  // Donation properties map.
  if (isset($map->field_map['fundraiser_sustainers_map'])) {
    if (isset($map->field_map['fundraiser_sustainers_map']['full_name'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['full_name'];
      $date = strtotime('now');
      if (!empty($donation->transaction_date)) {
        $date = strtotime($donation->transaction_date);
      }
      $fields[$sf_field] =  t('Recurring Donation - !first !last (!date)',
        array(
        '!first' => $donation->donation['first_name'],
        '!last' => $donation->donation['last_name'],
        '!date' => gmdate('Y-m-d H:i:s\Z', $date),
      ));
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['amount'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['amount'];
      $fields[$sf_field] = $donation->donation['amount'];
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['contact'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['contact'];
      $fields[$sf_field] = '[Contact:user:' . $donation->uid . ']';
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['installment_period'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['installment_period'];
      $fields[$sf_field] = 'Monthly';
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['schedule_type'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['schedule_type'];
      $fields[$sf_field] = 'Multiply By';
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['installments'])) {
      $info = _fundraiser_get_donation_gateway($donation->did);
      $months = 0;
      if ($op == 'update') {
        // This created donation is the master, so passing it in to create the set.
        // We can't predict the form key for these values, so ask the gateway to provide.
        if (isset($info['expire callback'])) {
          $expiration_func = $info['expire callback'];
          $expires = $expiration_func($donation->donation);
          $month = $expires['month'];
          $year = $expires['year'];
          $start = strtotime("now");
          $stop = mktime(0, 0, 0, $month, 1, $year);
          $months = ((idate('Y', $stop) * 12) + idate('m', $stop)) - ((idate('Y', $start) * 12) + idate('m', $start));
          $create_limit = variable_get('fundraiser_sustainers_create_limit', 50);
          if ($months > $create_limit) {
            $months = $create_limit;
          }
        }
      }
      $sf_field = $map->field_map['fundraiser_sustainers_map']['installments'];
      $fields[$sf_field] = $months;
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['last_payment_date'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['last_payment_date'];
      $fields[$sf_field] = date('Y-m-d H:i:s');
    }
    if (isset($map->field_map['fundraiser_sustainers_map']['next_payment_date'])) {
      $sf_field = $map->field_map['fundraiser_sustainers_map']['next_payment_date'];
      $fields[$sf_field] = date('Y-m-d H:i:s', $donation->recurring->next_charge);
    }
  }
  return $fields;
}

/**
 * Implements hook_salesforce_genmap_map_fields_alter().
 */
function fundraiser_sustainers_salesforce_genmap_map_fields_alter(&$fields, $context) {
  // Alter donations based on recurring status.
  if ($context['module'] == 'salesforce_donation') {
    $donation = $context['object'];
    $info = _fundraiser_get_donation_gateway($donation->did);
    $offsite_recurring = _fundraiser_sustainers_offsite_recurring($info['offsite_recurring'], $donation->donation['payment_method']);
    $map = $context['map'];

    // Add recurring item marker if recurring or not.
    $fields['Is_Recurring_Donation__c'] = FALSE;
    if ($donation->donation['recurs_monthly'] == TRUE) {
      $fields['Is_Recurring_Donation__c'] = TRUE;
    }

    // Add additional values for where not offsite recurring.
    if (!$offsite_recurring) {
      if (isset($map->field_map['salesforce_donation_map']['probability'])) {
        if ($donation->donation['recurs_monthly'] == TRUE && $donation->status_charged != 1) {
          $sf_field = $map->field_map['salesforce_donation_map']['probability'];
          $fields[$sf_field] = 50;
        }
      }
      if (isset($map->field_map['salesforce_donation_map']['stage'])) {
        $sf_field = $map->field_map['salesforce_donation_map']['stage'];
        if ($fields[$sf_field] == 'Posted' && $donation->donation['recurs_monthly'] == TRUE && $donation->status_charged != 1) {
          $sf_field = $map->field_map['salesforce_donation_map']['stage'];
          $fields[$sf_field] = 'Pledged';
        }
      }
      if (isset($map->field_map['salesforce_donation_map']['transaction_date'])) {
        $sf_field = $map->field_map['salesforce_donation_map']['transaction_date'];
        if ($donation->donation['recurs_monthly'] == TRUE && $donation->status_charged != 1) {
          $sf_field = $map->field_map['salesforce_donation_map']['transaction_date'];
          unset($fields[$sf_field]);
        }
      }
      // Lastly, add a field iff recurring object.
      if ($donation->donation['recurs_monthly'] == TRUE && !empty($donation->master_did) ) {
        $fields['npe03__Recurring_Donation__c'] = '[npe03__Recurring_Donation__c:recurring_donation:' . $donation->master_did . ']';
      }
      // Lastly, add a field iff recurring object.
      if ($donation->donation['recurs_monthly'] == TRUE && empty($donation->master_did) ) {
        $fields['npe03__Recurring_Donation__c'] = '[npe03__Recurring_Donation__c:recurring_donation:' . $donation->did . ']';
      }

      // If we're dealing with a sustainer charge, only send a subset of data so that other fields
      // that may have been changed in Salesforce isn't overwritten.
      if ($donation->donation['recurs_monthly'] == TRUE && $donation->status_charged == 1
         && !empty($donation->master_did) && $donation->did != $donation->master_did) {
        // @TODO: Add a configuration screen for specifying which fields get sent back
        // to Salesforce when a recurring donation charge is processed.
        $fields_to_update_on_charge = variable_get('fundraiser_sustainers_recurring_donation_charge_fields',
          array('StageName', 'Amount', 'Gateway_Reference__c', 'Transaction_Date_Time__c', 'Probability'));

        $mapped_fields = array_keys($fields);
        // Remove fields that are not to be updated when a sustainer is charged.
        foreach ($mapped_fields as $field) {
          if (!in_array($field, $fields_to_update_on_charge)) {
            unset($fields[$field]);
          }
        }
      }

      // Billing information has been modified for this donation series.
      if (isset($donation->update_billing) && $donation->update_billing) {
        // Truncate card number.
        if (isset($fields['CC_Last_4__c'])) {
          $fields['CC_Last_4__c'] = substr($fields['CC_Last_4__c'],-4,4);
        }
      }
      // Corrects the StageName to whatever value is appropriate based on mapped stages.
      if (isset($donation->donation_skipped) && $donation->donation_skipped) {
        if (isset($fields['StageName'])) {
          $stagename = 'Skipped';
          if (module_exists('salesforce_donation')) {
            $mapped_stages = array_flip(variable_get('salesforce_donation_mapped_stages', salesforce_donation_default_stage_map()));
            if (isset($mapped_stages['skipped'])) {
              $stagename = $mapped_stages['skipped'];
            }
          }
          $fields['StageName'] = $stagename;
        }
      }
    }
  }
}

/**
 * Node API Functions. Handle for each case of node operation.
 */

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node forms.
 */
function fundraiser_sustainers_form_node_form_alter(&$form, &$form_state, $form_id) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($form['#node']->type)) {
    $form['fundraiser_settings']['fundraiser_sustainers'] = array(
      '#type' => 'fieldset',
      '#title' => t('Fundraiser Recurring Display Settings'),
      '#desciption' => t('Modify the way the recurring option is displayed on this form, or if it is even available.'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['fundraiser_settings']['fundraiser_sustainers']['recurring_setting'] = array(
      '#type' => 'select',
      '#title' => t('Display setting'),
      '#options' => array(
        'user_choice' => t('Recurring is an option on this form, but users may opt out.'),
        'always' => t('Recurring is an option on this form, and users cannot opt out.'),
        'never' => t('Recurring is not an option on this form.'),
      ),
      '#default_value' => isset($form['#node']->recurring_setting) ? $form['#node']->recurring_setting : 'user_choice',
    );
  }
}

/**
 * Implements hook_node_insert().
 * Insert a copy of the default map when a Fundraiser node is created.
 */
function fundraiser_sustainers_node_insert($node) {
  if (fundraiser_is_donation_type($node->type)) {
    // If node is a donation type.
    $sustainers_node = array(
      'nid' => $node->nid,
      'recurring_setting' => $node->recurring_setting,
    );
    _fundraiser_sustainers_update_sustainers_node($sustainers_node);
  }

  if (fundraiser_is_donation_type($node->type) && module_exists('salesforce_genmap')) {
    // And if we have a default map.
    $nid = -1;
    if (!empty($node->clone_from_original_nid)) {
      $nid = $node->clone_from_original_nid;
    }
    $map = salesforce_genmap_load_map($nid, 'fundraiser_sustainers');
    if (!empty($map)) {
      // Copy the map to the node.
      unset($map->mid);
      $map->nid = $node->nid;
      salesforce_genmap_save_map($map, 'fundraiser_sustainers');
    }
  }
}

/**
 * Implements hook_node_load().
 */
function fundraiser_sustainers_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    // If this isn't a fundraiser type, ignore it.
    if (fundraiser_is_donation_type($node->type)) {
      // Get the fundraiser information.
      $fundraiser_sustainers = _fundraiser_sustainers_get_sustainers_node_by_nid($node->nid);
      // Merge data from fundraiser with node. Default to user_choice if no entry yet.
      $nodes[$node->nid]->recurring_setting = isset($fundraiser_sustainers->recurring_setting) ?
        $fundraiser_sustainers->recurring_setting : 'user_choice';
    }
  }
}

/**
 * Implements hook_node_update().
 */
function fundraiser_sustainers_node_update($node) {
  // If this isn't a fundraiser type, ignore it.
  if (fundraiser_is_donation_type($node->type)) {
    $sustainers_node = array(
      'nid' => $node->nid,
      'recurring_setting' => $node->recurring_setting,
    );
    _fundraiser_sustainers_update_sustainers_node($sustainers_node);
  }
}

/**
 * Implements hook_node_delete().
 * Insert a copy of the default map when a Fundraiser node is created.
 */
function fundraiser_sustainers_node_delete($node) {
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_sustainers_delete_sustainers_node($node->nid);
  }
  // If node is a donation type.
  if (fundraiser_is_donation_type($node->type) && module_exists('salesforce_genmap')) {
    salesforce_genmap_delete_map($node->nid, 'fundraiser_sustainers');
  }
}

/**
 * Implements hook_salesforce_sync_complete_item().
 * Acts when the queue returns a success.
 */
function fundraiser_sustainers_salesforce_sync_complete_item($item, $result) {
  if ($result->success) {
    if ($item->operation == 'CREATE') {
      if ($item->module == 'fundraiser_sustainers' && $item->object_type == 'npe03__Recurring_Donation__c') {
        $donation = fundraiser_donation_get_donation($item->drupal_id, TRUE);
        salesforce_genmap_send_object_to_queue('fundraiser_sustainers', 'update',
          $donation->node, $donation->did, $donation, 'recurring_donation');
      }
    }
  }
}

/**
 * Implements hook_fundraiser_donation_delete().
 */
function fundraiser_sustainers_fundraiser_donation_delete($donation) {
  if ($donation->donation['recurs_monthly'] == TRUE) {
    // If a recurring donation has been cancelled, we should drop it out of the recurring table.
    _fundraiser_sustainers_delete_recurring($donation->did);
  }
}

/**
 * Helper function, kick off recurring donations for payment. Called on cron usually.
 */
function fundraiser_sustainers_process_recurring_donations() {
  // Provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_recurring');
  $log = array(
    'successes' => 0,
    'fails' => 0,
  );
  $donations = _fundraiser_sustainers_cron_get_recurring();
  $sustainer_key = fundraiser_sustainers_get_sustainer_key_value();

  // Loop over the found orders
  foreach ($donations as $recurring) {
    fundraiser_sustainers_process_single_recurring_donation($log, $recurring, $sustainer_key);

  }
  if ($log['successes'] > 0 || $log['fails'] > 0) {
    watchdog('fundraiser_sustainers', '!successes recurring donations processed successfully; !fails failed.',
      array('!successes' => $log['successes'], '!fails' => $log['fails']));
  }
  // And after all of that is done, provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_post_recurring');
}

/**
 * Process an individual sustainer record.
 */
function fundraiser_sustainers_process_single_recurring_donation(&$log, $recurring, $sustainer_key) {
  if ($sustainer_key == $recurring->sustainer_key) {
    // Prepare a log record.
    $log_record = array(
      'did' => $recurring->did,
      'gateway' => $recurring->gateway,
      'date_processed' => time(),
      'lock_id' => $recurring->lock_id,
    );

    // Get the donation information that we need.
    $donation = fundraiser_donation_get_donation($recurring->did);

    // Set the reference charge flag to TRUE
    $donation->reference_charge = TRUE;

    // We can't handle the "processing" status from inside a transaction, so if any are open
    // then pop them off, forcing them to commit.
    $connection = Database::getConnection();
    if ($connection->inTransaction()) {
      $connection->popTransaction('drupal_transaction');
    }

    // Make sure this charge wasn't partially processed already (e.g., cron
    // crashed awaiting response from the gateway).
    if ('processing' == db_query("SELECT gateway_resp FROM {fundraiser_sustainers} WHERE did=:did;", array(':did' => $recurring->did))->fetchField()) {
      watchdog('fundraiser_sustainers', 'Sustainer order id !did tried to process for a second time! Skipped.',
        array('!did' => $recurring->did),
        WATCHDOG_CRITICAL
      );

      // Invoke a rules event so that an email can be configured when a dupe is discovered.
      if (module_exists("rules")) {
        rules_invoke_event("fundraiser_sustainer_duplicate_charge_attempt_detected", $donation->did);
      }

      return FALSE;
    }

    // Update the sustainer record to "processing"
    db_query("UPDATE {fundraiser_sustainers} SET gateway_resp='processing' WHERE did=:did;", array(':did' => $recurring->did));

    // Then go through each one of these to charge.
    // Since we already created the donation (and saved any CC info at that time).
    // All we need to do is process it and respond afterwards as needed.
    fundraiser_donation_process($donation);
    if (!isset($donation->result['message'])) {
      $donation->result['message'] = '';
    }
    // The results should be at $donation->result, ready to respond to the aftermath.
    if (isset($donation->result['success']) && $donation->result['success']) {
      fundraiser_donation_success($donation);
      // Record the success.
      $log['successes']++;
      $log_record['success'] = TRUE;
      // Perform any post-processing required by the gateway.
      module_invoke_all('fundraiser_sustainers_recurring_success', $donation);
    }
    else {
      $donation->result['success'] = FALSE;
      $log_record['success'] = FALSE;
      fundraiser_donation_decline($donation);
      // Record the fail.
      $log['fails']++;
    }

    // Write the log record.
    drupal_write_record('fundraiser_sustainers_log', $log_record);
  }
  else {
    // TODO: Unlock the sustainer record. Currently the lock has not been ported from D6.
    // Log the bad sustainer key check.
    watchdog('fundraiser_sustainers', 'Sustainer order id !did not processed because of sustainer key mismatch. ' .
      'Key file value (!key_file) did not match record value (!record_value).',
      array('!did' => $recurring->did, '!key_file' => $sustainer_key, '!record_value' => $recurring->sustainer_key), WATCHDOG_CRITICAL);
  }
}

/**
 * Menu callback for the my recurring payments tab of the user profile.
 */
function fundraiser_sustainers_user_overview($user, $did = NULL) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    return '<div>' . t('You have no recurring donations.') . '</div>';
  }
  else {
    if (!empty($did)) {
      return fundraiser_sustainers_edit_form($did);
    }
    else {
      // Else display the list.
      // Get the whole set of user donations (in case there's more than just this one). IIF the user owns this one.
      $donations_header = array('Amount', 'Start Date', 'Next Charge Date', 'Expire Date', 'Status');
      $donations_rows = array();
      foreach ($donations as $master_donation) {
        $this_donation = fundraiser_donation_get_donation($master_donation->master_did);
        // Grab the next to be charged for misc info.
        $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($master_donation->master_did);
        $this_next_donation = $this_donation;
        if ($remaining) {
          $this_next_donation = fundraiser_donation_get_donation($remaining[0]->did);
        }
        $edit_link = l('$' . money_format('%i', $this_next_donation->donation['amount']),
          'user/' . $this_next_donation->user->uid . '/recurring_overview/' . $master_donation->master_did);
        $donations_rows[] = array(
          'data' => array(
            'amount' => $edit_link,
            'start_date' => date('m/d/y', $master_donation->start_date),
            'next_charge' => !empty($master_donation->next_charge) ? date('m/d/y', $master_donation->next_charge) : '--/--/--',
            'expire_date' => date('m/d/y', $master_donation->expire_date),
            'status' => $master_donation->status,
          ),
          'class' => array('recurring-order'),
        );
      }
      $recurring_donations = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));
      return $recurring_donations;
    }
  }
}

/**
 * Implements hook_order().
 * From http://www.ubercart.org/docs/api/hook_order
 * When an order is deleted, keep fundraiser sustainer tables in sync if it's a donation too.
 */
function fundraiser_sustainers_order($op, &$arg1, $arg2) {
  switch ($op) {
    case 'delete':
      $donation = fundraiser_donation_get_donation($arg1->order_id); // Allowed use of order_id, ubercart is passing in an actual order.
      if ($donation) {
        fundraiser_donation_cancel($donation);
      }
      break;
  }
}

/**
 * Implements hook_fundraiser_field_info().
 */
function fundraiser_sustainers_fundraiser_field_info() {
  $fields['payment_information']['recurs_monthly'] = array(
    '#title' => 'Recurring Payment',
    '#type' => 'select',
    '#required' => 0,
    '#extra' => array(
      'description' => t('Selecting "Yes" will cause your credit card to be charged once per month until its expiration date.'),
      'items' => 'recurs|Yes',
      'multiple' => 1,
    ),
    '#allow_update' => 1,
    '#allow_respawn' => 1,
    '#reset_value' => 1,
    '#create_callback' => '_fundraiser_sustainers_recurs_monthly_field_create',
  );

  return $fields;
}

/**
 * Field create callback, adjsut the type of the recurring page shown, based on fundraiser settings.
 */
function _fundraiser_sustainers_recurs_monthly_field_create($fundraiser, $field) {
  // If recurring_settingdon't exist, drop the recurring field.
  if (empty($fundraiser->recurring_setting)) {
    return FALSE;
  }
  // If the show other options is disallowed, unset it.
  if ($fundraiser->recurring_setting == 'always') {
    $field['#type'] = 'hidden';
    $field['#extra'] = array(
      'description' => '',
      'hidden_type' => 'hidden',
    );
    $field['#value'] = 'recurs';
  }
  // If the show other options is disallowed, unset it.
  if ($fundraiser->recurring_setting == 'never') {
    $field['#type'] = 'hidden';
    $field['#extra'] = array(
      'description' => '',
      'hidden_type' => 'hidden',
    );
    $field['#value'] = 'NO_RECURR';
  }
  // Return the field to be created. Aka: user_choice
  return $field;
}

/**
 * Implements hook_fundraiser_donation_form().
 *
 * This hook is here for the purpose of adding a States array to the payment method options,
 * so that a non-recurring-enabled payment method will show/hide depending on the status of the
 * "recurring donation" field, if one exists. This hook also shows/hides the 'recurring' field.
 */
function fundraiser_sustainers_fundraiser_donation_form($form, $form_state) {
  // Find out whether the form has a checkbox/radio field called 'recurs_monthly'.
  $has_recurring_field = _fundraiser_sustainers_form_has_exposed_recurring_field($form['#node']->nid);

  // Nothing to do if the recurring field is not shown.
  if (empty($has_recurring_field['visible'])) {
    return;
  }

  // Set up the values that we're going to require in the States array. If it's a select list or
  // radio buttons, check for 'value'. Otherwise, it's a checkbox, so check for 'checked' == FALSE.
  if ($has_recurring_field['settings']['type'] == 'select' || $has_recurring_field['settings']['type'] == 'radios') {
    $required_values = array('!value' => 'recurs');
  }
  else {
    $required_values = array('checked' => FALSE);
  }

  $count_enabled_gateways = 0;
  $supporting_gateways = array();
  $selector = ':input[name*=recurs_monthly]';

  // Get the fields we'll be needing to work with.
  $payment_method_field = fundraiser_get_form_field('fundraiser_sustainers', $form, 'payment_method');
  $recurs_monthly_field = fundraiser_get_form_field('fundraiser_sustainers', $form, 'recurs_monthly');

  // Check if each gateway allows recurring payments, and use the States API if it doesn't.
  // Else, if it does, add its name to the 'supporting_gateways' array for showing/hiding the 'recurring' field.
  foreach ($form['#node']->gateways as $type => $payment_method) {
    if (!empty($payment_method['id']) && $payment_method['status'] == 1) {
      // Count the number of gateways currently enabled.
      $count_enabled_gateways++;

      // Get this gateway info and set its #states array.
      $this_gateway = _fundraiser_gateway_info($payment_method['id']);
      if (
        (!isset($this_gateway['allow_recurring'])
          || !_fundraiser_sustainers_supports_recurring($this_gateway['allow_recurring'], $payment_method['method'])
        )
        && $has_recurring_field['visible'] == TRUE
      ) {
        $payment_method_name = $payment_method['method'];
        $payment_method_field[$payment_method_name] = array(
          '#states' => array(
            'visible' => array(
              $selector => $required_values
            ),
          ),
        );
      }
      else {
        $supporting_gateways[] = $type;
      }
    }
  }

  // If no supporting gateways are on this form then do not save changes to the payment field.
  if (empty($supporting_gateways)) {
    // There are no gateways enabled that support recurring, hide the field.
    $recurs_monthly_field['#access'] = FALSE;
  }
  else {
    // Save the payment method field.
    $form = fundraiser_update_form_field('fundraiser_sustainers', $form, 'payment_method', $payment_method_field);

    // Modify the 'recurs_monthly' field. Set the #states array if there is a recurring-enabled
    // gateway; else, set the field to 'hidden' and give it a value of 'no_recurr'.
    if ($count_enabled_gateways > 1) {
      $recurs_monthly_field['#states'] = array(
        'invisible' => array(),
      );
      foreach ($supporting_gateways as $supporting_gateway) {
        $selector = ':input[name*=payment_method],value="' . $supporting_gateway . '"';
        $recurs_monthly_field['#states']['invisible'][$selector] = array('!value' => $supporting_gateway);
      }
    }
  }

  // Save the recurring field.
  $form = fundraiser_update_form_field('fundraiser_sustainers', $form, 'recurs_monthly', $recurs_monthly_field);

  // Add second validation handler that prevents sending a recurring donation
  // to a non-recurring-enabled payment gateway.
  $form['#validate'][] = 'fundraiser_sustainers_recurring_conflict_validate';
  return $form;
}

/**
 * Validation callback for donation webforms.
 *
 * This function checks whether the visitor chose to make a monthly recurring donation and also
 * chose a payment method that does not support recurring payments. This should be caught by
 * client-side validation but this catches any submission that makes it through.
 */
function fundraiser_sustainers_recurring_conflict_validate(&$form, &$form_state) {
  // Ensure we have submitted values and then flatten the array.
  if (empty($form_state['values']['submitted'])) {
    return;
  }
  $submission_fields = _fundraiser_webform_submission_flatten($form['#node']->nid, $form_state['values']['submitted']);

  // Only run through this validation if the form submit is recurring.
  $recurring_donation = FALSE;
  if (
    empty($submission_fields['recurs_monthly'])
    || empty($submission_fields['recurs_monthly']['recurs'])
    || (
      !empty($submission_fields['recurs_monthly']['recurs'])
      && ($submission_fields['recurs_monthly']['recurs'] != 'recurs')
    )
  ) {
    return;
  }

  // Load the gateway to see if the payment method supports recurring.
  $payment_method = $submission_fields['payment_method'];
  $gateway = _fundraiser_gateway_info($form['#node']->gateways[$payment_method]['id']);
  $supports_recurring = _fundraiser_sustainers_supports_recurring($gateway['allow_recurring'], $payment_method);

  // Now, return an error if necessary.
  if (!$supports_recurring) {
    $label = !empty($form['#node']->gateways[$payment_method]['label']) ? $form['#node']->gateways[$payment_method]['label'] : $gateway['details']['gateway_details']['display_title'];
    $error_message = t('Thank you for choosing a monthly donation!');
    $error_message .= t(' However, @payment_method does not support recurring monthly payments.', array('@payment_method' => $label));
    $error_message .= t(' Please choose a different method and submit the donation form again.');
    form_set_error('recurs_monthly', $error_message);
  }
}

/**
 * Helper function, find out if a node has recurring payments as an option.
 * It also gets the field's settings.
 */
function _fundraiser_sustainers_form_has_exposed_recurring_field($nid) {
  $webform_node = node_load($nid);

  // If the 'recurring_setting' is something other than 'user_choice',
  // that means the 'recurring' value on the webform are not exposed
  // to the visitor and thus we can go ahead and return FALSE values.
  if ($webform_node->recurring_setting != 'user_choice') {
    return array(
      'visible' => FALSE
    );
  } else {

    // Loop through webform components. When we find the one we want, get its settings.
    foreach ($webform_node->webform['components'] as $key => $component_contents) {
      if ($component_contents['form_key'] == 'recurs_monthly' && $component_contents['type'] == 'select') {
        // What type of selection component is it?
        if ($component_contents['extra']['aslist'] == 1) {
          $type = 'select';
        } else {
          $type = !empty($component_contents['extra']['multiple']) ? 'checkbox' : 'radios';
        }

        return array(
          'visible' => TRUE,
          'settings' => array(
            'type' => $type,
            'multiple' => !empty($component_contents['extra']['multiple'])
          ),
        );
      }
    }
  }
}

/**
 * Add validation to the recurring component edit form
 */
function fundraiser_sustainers_form_webform_component_edit_form_alter(&$form, $form_state) {
  list($node, $component, $clone) =  $form_state['build_info']['args'];
  if (fundraiser_is_donation_type($node->type)
   && $component['form_key'] == 'recurs_monthly') {
    $form['#validate'][] = '_fundraiser_sustainers_form_webform_component_edit_form_validate';
  }
}

/**
 * Validates the recurring component edit form to ensure the 'recurs' value is in the Options
 */
function _fundraiser_sustainers_form_webform_component_edit_form_validate(&$form, $form_state) {
  if (strpos($form_state['values']['extra']['items'], 'recurs|') === FALSE) {
    form_set_error('extra][items', t('The Options for this field must contain the value \'recurs\'.'));
  }
}

/**
 * Implements hook_fundraiser_donation_information_table_alter().
 */
function fundraiser_sustainers_fundraiser_donation_information_table_alter(&$variables, $donation) {
  if ($donation->sid == 0) {
    $recurring = _fundraiser_sustainers_get_recurring_by_did($donation->did);
    if (!empty($recurring->master_did)) {
      $variables['rows'][] = array(t('This donation is part of a sustainer donation set.'), '');
      $master_donation = fundraiser_donation_get_donation($recurring->master_did);
      if (!empty($master_donation->did)) {
        $variables['rows'][] = array('Fundraiser parent donation submission', t('#@sid - !title',
          array('@sid' => $master_donation->sid, '!title' => l(t('View submission'),
            'node/' . $master_donation->node->nid . '/submission/' . $master_donation->sid))));
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Adds the admin form for crons to the fundraiser settings form.
 */
function fundraiser_sustainers_form_fundraiser_admin_settings_alter(&$form, &$form_state) {
  // Turn on option to process sustainer donations on own cron.
  $form['fundraiser_sustainers'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fundraiser sustainers'),
    '#description' => t('Configure fundraiser sustainers settings.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['fundraiser_sustainers']['fundraiser_sustainers_create_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Creation limit'),
    '#description' => t('How many charges max to make off a successful charge.'),
    '#default_value' => variable_get('fundraiser_sustainers_create_limit', 50),
  );
  $form['fundraiser_sustainers']['fundraiser_cron'] = array(
    '#type' => 'fieldset',
    '#title' => t('Cron settings'),
    '#description' => t('Configure cron settings.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['fundraiser_sustainers']['fundraiser_cron']['fundraiser_standalone_cron_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable standalone cron.'),
    '#description' => t('If this option is enabled all fundraiser related cron tasks will be removed from the ' .
      'standard cron run. These tasks will need to be cronned separately via sitename/fundraiser_cron'),
    '#default_value' => variable_get('fundraiser_standalone_cron_enabled', 0),
  );
  // CC expiration message to send when sustainer donation is almost out.
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message'] = array(
    '#type' => 'fieldset',
    '#title' => t('Credit card expiration email'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_sustainers_send_email'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send expiration email'),
    '#description' => t('If this option is enabled then emails will be sent when a card is about to expire.'),
    '#default_value' => variable_get('fundraiser_sustainers_send_email', TRUE),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_cc_exp_subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Email subject'),
    '#default_value' => variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire'),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_cc_exp_body'] = array(
    '#type' => 'textarea',
    '#title' => t('Email body'),
    '#default_value' => variable_get('fundraiser_cc_exp_body',
      'Your card ending in [donation:card_number] is about to expire on [donation:card_expiration_month]/[donation:card_expiration_year].'),
    '#description' => t('The body of the email. Available tokens are below.'),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['tokens'] = array(
    '#type' => 'fieldset',
    '#title' => t('Donor replacement tokens'),
    '#description' => t('The following tokens are available for sustainer emails.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $token_set = array('donation', 'user', 'node');
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['tokens']['token_help'] = array(
    '#type' => 'item',
    '#title' => t('Drupal tokens'),
    '#description' => theme('token_tree', array('token_types' => $token_set, 'recursion_limit' => 2, 'click_insert' => FALSE)),
  );
  $form['#submit'][] = 'fundraiser_update_cron_settings';
}

/**
 * Submit handler updates cron menu handler.
 */
function fundraiser_update_cron_settings($form, $form_state) {
  $cron_enabled = variable_get('fundraiser_standalone_cron_enabled', 0);
  if ($cron_enabled != $form_state['values']['fundraiser_standalone_cron_enabled']) {
    variable_set('fundraiser_standalone_cron_enabled', $form_state['values']['fundraiser_standalone_cron_enabled']);
    // Refresh menu cache.
    menu_rebuild();
  }
}

/**
 * Provide administrative form for editting a donation set.
 */
function fundraiser_sustainers_edit_form($did) {
  // Add js and css to the form.
  $base = drupal_get_path('module', 'fundraiser_sustainers');
  drupal_add_js($base . '/js/sustainer.js');
  drupal_add_css($base . '/css/sustainer.css');

  // Grab all associated donation information.
  $donation = fundraiser_donation_get_donation($did);

  // Check permissions, we don't want to show this to someone who doesn't have permission.
  global $user;
  if (($donation->user->uid != $user->uid) && !user_access('administrate recurring donations')) {
    return t('You do not have access to this recurring donation.');
  }

  // Grab the next to be charged for misc info.
  $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($donation->did);
  $next_donation = $donation;
  if ($remaining) {
    $next_donation = fundraiser_donation_get_donation($remaining[0]->did);
  }

  $number = FALSE;
  if (isset($donation->data['payment_fields']['credit']['card_number'])) {
    $number = '**** **** **** '  . $donation->data['payment_fields']['credit']['card_number'];
    $type = t('Card ');
  }
  elseif (isset($donation->data['payment_fields']['bank account']['accNum'])) {
    $number = '********* ' . $donation->data['payment_fields']['bank account']['accNum'];
    $type = t('Checking Account');
  }

  // Gather further donation data.
  $remaining_donation_count = _fundraiser_sustainers_count_donations_recurr_remaining($did);
  $payment_info = '<div id="payment-info">' .
  '<h2>Recurring Payment Info</h2>' .
  '<dl>' .
  '<dt>Recurring Donation Amount</dt>' .
  '<dd>$' . money_format('%i', $next_donation->donation['amount'] ) . '</dd>' .
  '<dt>Recurring Charges Processed</dt>' .
  '<dd>' . _fundraiser_sustainers_count_donations_recurr_processed($did) . '</dd>' .
  '<dt>Recurring Charges Remaining</dt>' .
  '<dd>' . $remaining_donation_count . '</dd>';
  if ($number) {
    $payment_info .= '<dt>'. $type . ' Number</dt>' .
    '<dd>' . $number . '</dd>';
  }
  $payment_info .= '</dl>' .
  '</div>';

  $billing_info = '<div id="billing-info">' .
  '<h2>Billing Address</h2>' .
  '<address>' .
  $next_donation->donation['address'] . '<br />' .
  $next_donation->donation['city'] . ', ' . $next_donation->donation['state'] . ' ' . $next_donation->donation['zip'] .
  '</address>';
  // If the logged in viewing user is NOT the same as the donation user.
  if ($donation->user->uid != $user->uid) {
    $billing_info .= '<div id="additioanl-billing-info">Customer Account: <a href=\'/user/' . $next_donation->uid . '\'>' .
      $next_donation->user->name . '</a>' .
      '<br />Primary email: ' . $next_donation->user->mail . '</div>';
  }
  $billing_info .= '</div>';

  // Format payment schedule into a data table
  $donation_set = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  $donations_header = array('Amount', 'Charge Date', 'Processed Status');


  if (user_access('fastforward recurring donations')) {
    // Add a button to fastforward this particular donation
    $donations_header[] = t('Advance Charge to Today');
  }
  if (user_access('skip recurring donations')) {
    $donations_header[] = t('Skip Charge');
  }
  $donations_rows = array();
  if ($donation_set) {
    foreach ($donation_set as $this_donation) {
      $this_donation = fundraiser_donation_get_donation($this_donation->did);
      $donations_row['amount'] = '$' . money_format('%i', $this_donation->donation['amount']);
      $donations_row['charge_date'] = date('m/d/y', $this_donation->recurring->next_charge);
      if (empty($this_donation->status)) {
        $this_donation->status = t('Pending');
      }
      $donations_row['status'] = !empty($this_donation->status_label) ? $this_donation->status_label : $this_donation->status;
      if (user_access('fastforward recurring donations')) {
        if (isset($this_donation->status_charged) && !$this_donation->status_charged) {
          // Add a button to fastforward this particular donation
          $donations_row['ffwd'] = l(t('advance charge'), 'fundraiser_sustainers/ffwd/' . $this_donation->did,
            array('query' => drupal_get_destination()) );
        }
        else {
          $donations_row['ffwd'] = t('cannot update');
        }
      }
      if (user_access('skip recurring donations')) {
        if (isset($this_donation->status_charged) && !$this_donation->status_charged) {
          // Add a button to fastforward this particular donation
          $donations_row['skip'] = l(t('skip charge'), 'fundraiser_sustainers/' . $did . '/skip/' . $this_donation->did,
            array('query' => drupal_get_destination()));
        }
        else {
          $donations_row['skip'] = $this_donation->status == 'skipped' ? t('already skipped') : t('cannot skip');
        }
      }
      $donations_rows[] = $donations_row;
    }
  }
  $future_orders = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));
  $future_orders = '<div id="payment-schedule">' .
  '<h2>Payment Schedule</h2>' .
  $future_orders .
  '</div>';

  // Check if this order is already cancelled.
  $cancelled = isset($next_donation->recurring->cancellation_reason) ? $next_donation->recurring->cancellation_reason : '';

  // Generate forms, or error messages as needed.
  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $donation_amount_form_array = drupal_get_form('fundraiser_sustainers_donation_amount_form', $donation, $next_donation);
    $donation_amount_form = drupal_render($donation_amount_form_array);
    if (user_access('set new recurring charge date')) {
      // If date mode is enabled and on, do not support changing the payment date.
      if (module_exists('fundraiser_date_mode') && variable_get('fundraiser_date_mode_set_date_mode', 0) == 1) {
        $donation_date_form = '';
      }
      else {
        $donation_date_form_array = drupal_get_form('fundraiser_sustainers_donation_date_form', $donation);
        $donation_date_form = drupal_render($donation_date_form_array);
        $donation_date_form = '<div id="donation-date-form"><h2>Change Charge Date</h2>' . $donation_date_form . '</div>';
      }
    }
    else {
      $donation_date_form = '';
    }
  }
  elseif ($remaining_donation_count == 0) {
    $donation_amount_form = t('There are no further charges for this recurring donation.');
    $donation_date_form = '';
  }
  else {
    $donation_amount_form = t('This recurring donation has been cancelled.');
  }
  $donation_amount_form = '<div id="donation-amount-form"><h2>Update Donation Amount</h2>' . $donation_amount_form . '</div>';

  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $billing_update_form_array = drupal_get_form('fundraiser_sustainers_billing_update_form', $next_donation);
    $billing_update_form = drupal_render($billing_update_form_array);
  }
  elseif ($remaining_donation_count == 0) {
    $billing_update_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $billing_update_form = t('This recurring donation has been cancelled.');
  }
  $billing_update_form = '<div id="donation-billing-form"><h2>Update Your Credit Card Information</h2>' . $billing_update_form . '</div>';

  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $cancel_form_array = drupal_get_form('fundraiser_sustainers_cancel_form', $next_donation);
    $cancel_form = drupal_render($cancel_form_array);
  }
  elseif ($remaining_donation_count == 0) {
    $cancel_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $cancel_form = t('This recurring donation has been cancelled. Your reason given was: %reason', array('%reason' => $cancelled));
  }
  if (user_access('cancel future donations')) {
    $cancel_form = '<div id="donation-cancel-form"><h2>Cancel Future Donations</h2>' . $cancel_form . '</div>';
  }
  else {
    $cancel_form = '';
  }
  // Put together the output.
  drupal_set_title(t('Recurring donation #@did', array('@did' => $did)));
  $parts = array($payment_info, $billing_info, $future_orders, $donation_amount_form, $donation_date_form, $billing_update_form, $cancel_form);
  return implode('', $parts);
}

/**
 * Creates a form for donation amount update.
 */
function fundraiser_sustainers_donation_amount_form($form, &$form_state, $donation, $next_donation) {
  // Abort if the gateway does not support recurring.
  $info = _fundraiser_get_donation_gateway($donation->did);
  if (!_fundraiser_sustainers_supports_recurring($info['allow_recurring'], $donation->donation['payment_method'])) {
    $form['fundraiser-sustainer-billing'] = array(
      '#markup' => '<div class="fundraiser-sustainer-no-recur-support">' .
        t('This payment gateway does not support recurring donations and cannot be updated.') .
        '</div>',
    );
    return $form;
  }

  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['min_amount'] = array(
    '#type' => 'hidden',
    '#value' => isset($donation->node->minimum_donation_amount) ? $donation->node->minimum_donation_amount : 0,
  );
  $form['fee_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Donation Amount'),
    '#size' => 10,
    '#required' => TRUE,
    '#description' => t('Your current donation amount is %amount. Minimum donation %minimum.',
      array(
        '%amount' => money_format('%i', $next_donation->donation['amount']),
        '%minimum' => money_format('%i', isset($donation->node->minimum_donation_amount) ? $donation->node->minimum_donation_amount : 0))
      ),
    '#field_prefix' => '$',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update donation amount'),
  );
  $form['#donation'] = $donation;
  return $form;
}

/**
 * Form validation handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['fee_amount'])) {
    form_set_error('amount', t('Donation amount must be a valid number.'));
  }
  if ($form_state['values']['fee_amount'] < $form_state['values']['min_amount']) {
    form_set_error('amount', t('Donation amount must be greater than %minimum',
      array('%minimum' => money_format('%i', $form_state['values']['min_amount']))));
  }
}

/**
 * Form submit handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_submit($form, &$form_state) {
  $amount = $form_state['values']['fee_amount'];
  $master_did = $form_state['values']['master_did'];
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($donations as $donation) {
    $donation = fundraiser_donation_get_donation($donation->did);
    $old_amount = $donation->donation['amount'];
    $donation->donation['amount'] = $amount;
    $donation->donation['old_amount'] = $old_amount;

    // Let other modules know the amount has been updated
    $donation->update_amount = TRUE;

    fundraiser_donation_update($donation);

    // Add a comment.
    global $user;
    $username = isset($user->name) ? $user->name : 'Anonymous';
    fundraiser_donation_comment($donation, 'The amount of this gift was changed from $@old_amount to $@new_amount on @date by @username.',
      array(
      '@old_amount' => $donation->donation['old_amount'],
      '@new_amount' => $donation->donation['amount'],
      '@date' => format_date(strtotime('now')),
      '@username' => $username,
    ));

    // update sf queue.
    if (module_exists('salesforce_genmap')) {
      salesforce_genmap_send_object_to_queue('salesforce_donation', 'update',
        $donation->node, $donation->did, $donation, 'donation');
    }
  }
  drupal_set_message(t('The amount of all future donations has been updated to @amount.', array('@amount' => $amount)));
}

/**
 * Creates a form for donation date change.
 */
function fundraiser_sustainers_donation_date_form($form, &$form_state, $donation) {

  $recurring = _fundraiser_sustainers_get_donations_recurr_remaining($donation->did);
  $custom_day = db_query("SELECT day FROM {fundraiser_sustainers_charge_date} WHERE master_did = :did", array(':did' => $donation->recurring->master_did))->fetchField();
  $next = isset($recurring[0]->next_charge) ? date('j', $recurring[0]->next_charge) : 1;
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $dates = array_combine(range(1, 28), range(1, 28));
  $form['fundraiser_sustainers_change_dates'] = array(
    '#type' => 'select',
    '#title' => t('Select the day of the month for your recurring donation to charge'),
    '#description' => t('This will change the date on which your recurring donation processes each month, beginning with next month\'s transaction.'),
    '#options' => $dates,
    '#multiple' => FALSE,
    '#default_value' => !empty($custom_day) ? $custom_day : $next,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update donation charge date'),
  );
  $form['#donation'] = $donation;
  return $form;
}

/**
 * Submits a form for donation date change.
 */
function fundraiser_sustainers_donation_date_form_submit($form, &$form_state) {
  $master_did = $form_state['values']['master_did'];
  $new_day = $form_state['values']['fundraiser_sustainers_change_dates'];

  // Update the sustainers charges with new date.
  fundraiser_sustainers_change_charge_date($master_did, $new_day);

  // Record the change in db.
  $data = array(
    'master_did' => $master_did,
    'day' => $new_day,
  );
  $already_has_custom_date = db_query("SELECT day FROM {fundraiser_sustainers_charge_date} WHERE master_did = :did", array(':did' => $master_did))->fetchField();
  if (empty($already_has_custom_date)) {
    drupal_write_record('fundraiser_sustainers_charge_date', $data);
  }
  else {
    drupal_write_record('fundraiser_sustainers_charge_date', $data, 'master_did');
  }
  drupal_set_message(t('The date of all future donations has been updated'));
}

/**
 * Calculates new next charge dates.
 */
function fundraiser_sustainers_change_charge_date($master_did, $new_day) {
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  $current_time = _fundraiser_sustainers_explode_date(time());
  foreach ($donations as $donation) {
    $old_charge_date = $donation->next_charge;
    // Ignore orders that are ready to process.
    if ($old_charge_date < time()) {
      continue;
    }
    $donation_time = _fundraiser_sustainers_explode_date($old_charge_date);
    // If the next charge is in this month, leave it alone.
    // This should prevent sliding charges into the past.
    if ($donation_time['year'] == $current_time['year'] && $donation_time['month'] == $current_time['month']) {
      continue;
    }
    else {
      $donation = fundraiser_donation_get_donation($donation->did);
      $original_charge_date = date('j', $old_charge_date);
      $delta = ($original_charge_date - $new_day) * 86400;
      $time_delta = $delta * -1;

      if ($time_delta < 0) {
        $operator = '-';
        $time_delta = $time_delta * -1;
      }
      else {
        $operator = '+';
      }

      $query = db_update('fundraiser_sustainers')
        ->expression('next_charge', '( next_charge ' . $operator . ' :delta )', array(':delta' => $time_delta))
        ->condition('master_did', $master_did, '=')
        ->condition('did', $donation->did, '=')
        ->execute();

      // Add a comment.
      global $user;
      $username = isset($user->name) ? $user->name : 'Anonymous';
      $message =  t('The date of this gift was changed from @old_day to @new_day on @date by @username.',
        array(
        '@old_day' => date('m/d/Y', $old_charge_date),
        '@new_day' => date('m/', $old_charge_date) . str_pad($new_day, 2, '0', STR_PAD_LEFT) . date('/Y', $old_charge_date),
        '@date' => format_date(strtotime('now')),
        '@username' => $username,
      ));
      $order = commerce_order_load($donation->did);
      $order->revision = TRUE;
      $order->log = $message;
      commerce_order_save($order);

      // update sf queue.
      if (module_exists('salesforce_genmap')) {
        $sf_donation = fundraiser_donation_get_donation($donation->did, TRUE);
        salesforce_genmap_send_object_to_queue('salesforce_donation', 'update',
          $sf_donation->node, $sf_donation->did, $sf_donation, 'donation');
      }
    }
  }
}

function _fundraiser_sustainers_explode_date($timestamp) {
  $date_string = date('Y/n/j/G/i/s', $timestamp);
  $date = explode('/', $date_string);
  $time = array(
    'year' => $date[0],
    'month' => $date[1],
    'day' => $date[2],
    'hour' => $date[3],
    'minute' => $date[4],
    'second' => $date[5],
  );
  return $time;
}

/**
 * Creates form for billing address update.
 */
function fundraiser_sustainers_billing_update_form($form, &$form_state, $donation) {
  // Attach the js files
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'fundraiser') . '/js/jquery.alphanumeric.min.js',
    drupal_get_path('module', 'fundraiser') . '/js/jquery.validate.min.js',
    drupal_get_path('module', 'fundraiser') . '/js/donation_validation.js',
  );
  // Abort if the gateway does not support recurring.
  $info = _fundraiser_get_donation_gateway($donation->did);
  if (!_fundraiser_sustainers_supports_recurring($info['allow_recurring'], $donation->donation['payment_method'])) {
    $form['fundraiser-sustainer-billing'] = array(
      '#markup' => '<div class="fundraiser-sustainer-no-recur-support">' .
        t('This payment gateway does not support recurring donations and cannot be updated.') .
        '</div>',
    );
    return $form;
  }
  $form['#attributes']['class'][] = 'fundraiser-donation-form';
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $donation->uid,
  );

  // The rest of this is based on fields generated from fundraiser.
  $field_info = _fundraiser_field_info();
  // The parts we need to allow for updating: donor info, billing and credit card.
  $form['billing_information'] = array(
    '#type' => 'fieldset',
    '#title' => t('Billing Address'),
    '#attributes' => array('id' => 'billing-address'),
  );
  $billing_fields = array_merge($field_info['donor_information'], $field_info['billing_information']);
  foreach (element_children($billing_fields) as $field_key) {
    $field = $billing_fields[$field_key];
    $form['billing_information'][$field_key] = _fundraiser_sustainers_create_field_from_info($donation, $field_key, $field);
  }

  // CC info.
  $form['payment_method'] = array(
    '#type' => 'hidden',
    '#value' => $donation->donation['payment_method'],
  );
  $form['payment_fields'] = array(
    '#type' => 'fieldset',
    '#title' => 'Payment Information',
    '#attributes' => array('id' => 'credit-card-info'),
    '#tree' => TRUE,
  );
  $form['payment_fields'][$donation->donation['payment_method']] = array(
    '#type' => 'fieldset',
    '#attributes' => array('id' => 'credit-card-info'),
  );
  // Pull the gateway form from the donation gateway.
  // Once set a gateway CANNOT be changed on a donation series.
  // Check against the gateway config for a specific form to go with this payment gateway.
  if (isset($donation->gateway['form callback'])) {
    $form_func = $donation->gateway['form callback'];
    if (function_exists($form_func)) {
      $form['payment_fields'][$donation->donation['payment_method']] += $form_func($donation->donation['payment_method']);
    }
  }

  // And add a submit button.
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save changes'),
  );
  $form['#donation'] = $donation;

  // Modify form displays according to callback settings.
  // This allows any other systems to modify the available options with callbacks.
  $form['#calling_module'] = 'fundraiser_sustainers';
  fundraiser_display_form_fields('fundraiser_sustainers', $form, $form_state);

  return $form;
}

/**
 * Afterbuild for the billing form.
 */
function fundraiser_sustainers_billing_update_after_build($form, &$form_state) {
  return fundraiser_donation_form_after_build($form, $form_state);
}

/**
 * Helper function, generate fields from given field_info.
 */
function _fundraiser_sustainers_create_field_from_info($donation, $field_key, $field_info) {
  $field = array(
    '#type' => $field_info['#type'],
    '#title' => t('@title', array('@title' => $field_info['#title'])),
    '#required' => (isset($field_info['#required']) && $field_info['#required'] == 1) ? TRUE : FALSE,
    '#default_value' => $donation->donation[$field_key],
  );
  if ($field_info['#type'] == 'select') {
    $options = array();
    $items = $field_info['#extra']['items'];
    $items = explode("\n", $items);
    foreach ($items as $item) {
      $items_values = explode('|', $item);
      $key = trim($items_values[0]);
      $label = isset($items_values[1]) ? trim($items_values[1]) : $key;
      if (!empty($key)) {
        $options[$key] = $label;
      }
    }
    $field['#options'] = $options;
    $field['#multiple'] =
      (isset($field_info['#extra']['multiple']) && $field_info['#extra']['multiple'] == 1) ? TRUE : FALSE;
  }
  return $field;
}

/**
 * Form validation handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_validate($form, &$form_state) {
  // Submission fields are keyed according to the fields in _fundraiser_field_info().
  // Select only the ones we want to validate with fundraiser.
  $submission_fields = $form_state['values'];
  // Clean up the gateway information as needed on validation.
  if (isset($form['#donation']->gateway['cleanup callback'])) {
    $validate_cleanup_func = $form['#donation']->gateway['cleanup callback'];
    if (function_exists($validate_cleanup_func)) {
      $submission_fields = $validate_cleanup_func($submission_fields);
    }
  }

  // If it's a credit card, do some generic validation.
  // This is because the gateway's validation doesn't happen during a
  // billing update.
  $credit_card_errors = array();
  if ($submission_fields['payment_method'] == 'credit') {
    // This returns an array.
    $credit_card_errors = fundraiser_commerce_generic_credit_card_validate($submission_fields['payment_fields']);
    if (count($credit_card_errors)) {
      foreach ($credit_card_errors as $form_key => $message) {
        form_set_error('payment_fields][credit][' . $form_key, $message);
      }
    }
  }

  // This returns a boolean.
  // From fundraiser.module.
  $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields);

  if (form_get_errors() || count($credit_card_errors) || $errors) {
    // We've set a form_error by now.
    drupal_set_message(t('Unable to update credit card information.'));
  }
}

/**
 * Form submit handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_submit($form, &$form_state) {
  $master_did = $form_state['values']['master_did'];
  // We only update donations to come, not ones already processed.
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  $submission_fields = $form_state['values'];
  // Clean up the gateway information as needed on validation.
  if (isset($form['#donation']->gateway['cleanup callback'])) {
    $validate_cleanup_func = $form['#donation']->gateway['cleanup callback'];
    if (function_exists($validate_cleanup_func)) {
      $submission_fields = $validate_cleanup_func($submission_fields);
    }
  }

  // Remove unnecessary values.
  unset($submission_fields['master_did']);
  unset($submission_fields['uid']);

  // Set a flag for other modules to respond to the first order being updated in series
  $sustainer_update_first = TRUE;

  foreach ($donations as $donation) {
    // Get the original donation.
    $donation = fundraiser_donation_get_donation($donation->did);
    // Update it.
    $donation->donation = array_merge($donation->donation, $submission_fields);

    // Mark the billing information as needing to be updated.
    $donation->update_billing = TRUE;

    // Mark the payment information as needing to be updated.
    $donation->update_payment = TRUE;

    // Let other modules know this is a sustainer update
    $donation->sustainer_update = TRUE;

    // Let other modules know the first donation being updated in the series
    if ($sustainer_update_first) {
      $sustainer_update_did = $donation->did;
    }
    else {
      $donation->sustainer_update_did = $sustainer_update_did;
    }

    $donation->sustainer_update_first = $sustainer_update_first;

    // Save each donation.
    fundraiser_donation_update($donation);

    // The first donation will be used by the create recurring function
    if ($sustainer_update_first) {
      $source_donation = $donation;
    }

    // Set the first flag to false for the rest of the donations
    $sustainer_update_first = FALSE;

    // Add a comment.
    global $user;
    $username = isset($user->name) ? $user->name : 'Anonymous';
    fundraiser_donation_comment($donation, 'The card to be charged was changed on @date by @username.',
      array('@date' => format_date(strtotime('now')), '@username' => $username));
    watchdog('fundraiser_sustainers', 'Billing information updated for #@did.',
      array('@did' => $donation->did));

    // Update salesforce.
    if (module_exists('salesforce_genmap')) {
      salesforce_genmap_send_object_to_queue('salesforce_donation', 'update',
        $donation->node, $donation->did, $donation, 'donation');
    }
  }
  // Load the master donation.
  $master_donation = fundraiser_donation_get_donation($master_did);
  // Update this donation (don't save it) so we have the right parentage with the new billing.
  $master_donation->donation = array_merge($master_donation->donation, $submission_fields);
  // Create new orders based on expiration date as needed.
  // But we need to retrieve the month / year values from gateway form.
  // We can't predict the form key for these values, so ask the gateway to provide.
  if (isset($form['#donation']->gateway['expire callback'])) {
    $expiration_func = $form['#donation']->gateway['expire callback'];
    if (function_exists($expiration_func)) {
      $expires = $expiration_func($submission_fields);
      if (isset($expires['month']) && isset($expires['year'])) {
        // Set master donation amount to next recurring amount, so if we've updated amounts we get the right one.
        $master_donation->donation['amount'] = $donation->donation['amount'];
        // Create new orders.
        _fundraiser_sustainers_create_future_orders($master_donation, $expires['month'], $expires['year'], $source_donation, $master_donation->recurring->next_charge);
      }
      // If a custom charge date was set by an admin, update the charge dates.
      $date_mode = (module_exists('fundraiser_date_mode') && variable_get('fundraiser_date_mode_set_date_mode', 0) == 1) ? TRUE : FALSE;
      $custom_charge_date = db_query("SELECT day FROM {fundraiser_sustainers_charge_date} WHERE master_did = :did", array(':did' => $master_did))->fetchField();
      if (!empty($custom_charge_date) && !$date_mode)  {
        fundraiser_sustainers_change_charge_date($master_did, $custom_charge_date);
      }
    }
  }
  drupal_set_message(t('Billing information successfully updated'));
}

/**
 * Create recurring donations up until the date given.
 *
 * If the recurring donations exist already update,
 * cancelling those that are past expiration.
 *
 * @param object $donation
 *   The donation that will become the master donation..
 * @param int $month
 *   The month number to stop on.  Usually the credit card expiration.
 * @param int $year
 *   The year number to stop on.  Usually the credit card expiration.
 * @param object $source_donation
 *   The donation to copy if different than the master donation.
 * @param int $start
 *   The timestamp to start from.  If not set will default to now.
 *   The first non-master donation will happen one month after the $start.
 *
 */
function _fundraiser_sustainers_create_future_orders($donation, $month, $year, $source_donation = NULL, $start = NULL) {
  // Handle the rest of the set based on the given donation.
  if (is_null($start)) {
    $start = strtotime("now");
  }

  $previous_charge = $start;

  $stop = mktime(0, 0, 0, $month, 1, $year);
  $months = ((idate('Y', $stop) * 12) + idate('m', $stop)) - ((idate('Y', $start) * 12) + idate('m', $start));
  $processed_months = 0;
  $sustainer_key = fundraiser_sustainers_get_sustainer_key_value();

  // Start counting.
  $create_limit = variable_get('fundraiser_sustainers_create_limit', 50);
  // Get existing donations, if they exist.
  $existing_recurring = _fundraiser_sustainers_get_donations_recurr_by_masterdid($donation->did);

  unset($existing_recurring[0]); // 0 is the master, we don't need to count it.
  while ($processed_months < $months && $processed_months < $create_limit) {
    $processed_months++;
    // Check if we have a donation for this next month.
    if (!isset($existing_recurring[$processed_months])) {
      // Create a new one donation from the source or master donation
      $new_donation = !empty($source_donation) ? _fundraiser_donation_copy($source_donation) : _fundraiser_donation_copy($donation);
      $new_donation->sid = 0; // Not actually submitted, it's automated, so no sid.
      // Create the new donation object, but do not process it. Processing doesn't occur till cron.
      // New donation has all of the old donation information already loaded.

      // Add a flag so modules know this is being created by the sustainer system
      $new_donation->sustainer_create = TRUE;

      // Remove the reference charge flag
      unset($new_donation->reference_charge);

      fundraiser_donation_create($new_donation);

      // Build a context to determine the next charge date.
      $context = array(
        'master_did' => $donation->did,
        'did' => $new_donation->did,
      );

      $next_charge = fundraiser_sustainers_get_next_charge_time($previous_charge, $context);

      fundraiser_donation_comment($new_donation, 'Sustainer donation scheduled to be charged at @next_charge',
        array('@next_charge' => format_date($next_charge)));
      // After this, the donation did and donation data is set.
      // The new donation object, with new did, needs to be saved to recurring
      // so we can grab it later.
      $recurring_donation = array(
        'master_did' => $donation->did,
        'did' => $new_donation->did,
        'next_charge' => $next_charge,
        'sustainer_key' => $sustainer_key,
      );
      // Update the recurring table.
      _fundraiser_sustainers_create_recurring($recurring_donation);
      // Load the newly created individual donation into salesforce_donation.
      if (module_exists('salesforce_genmap')) {
        $sf_donation = fundraiser_donation_get_donation($new_donation->did, TRUE);
        salesforce_genmap_send_object_to_queue('salesforce_donation', 'insert',
          $sf_donation->node, $sf_donation->did, $sf_donation, 'donation');
      }
    }
    else {
      // Unset this from the existing recurring. By the time this loop is done,
      // only recurring orders outside of our range will still be in the set.
      unset($existing_recurring[$processed_months]);
      // If an existing recurring order is changed to use a card with a later
      // expiration than the original card, we will need to add orders to the
      // series. Iterating $previous_charge by a month for each existing order
      // in the series keeps it in sync with the month as we advance through
      // the existing orders.
      $previous_charge = strtotime('+1 month', $previous_charge);
    }
  }

  // Done with the loop, everything has been created that needs to be created.
  // But now we need to remove anything that existed in the set beyond our
  // expiration date.
  global $user;
  foreach ($existing_recurring as $key => $recurring) {
    $this_donation = fundraiser_donation_get_donation($recurring->did);
    // Cancel the donation with an informative message.
    watchdog('fundraiser', 'Donation @id was deleted by @user while updating the card expiration date.',
      array('@id' => $donation->did, '@user' => $user->name), WATCHDOG_DEBUG, NULL);

    // Delete these donations so do won't appear in the list of recurring donations.
    fundraiser_donation_delete($this_donation);
  }
}

/**
 * Determine the next_charge time taking any altering into account.
 *
 * @param null|int $time
 *   A timestamp as provided by strtotime(), or NULL to use now.
 *   Either the current time or the time of the previous charge
 *   in order to get back the next scheduled time to charge.
 * @param array $context
 *   An associative array potentially including a 'master_did' and a new
 *   donation 'did'.
 *
 * @return int
 *   The timestamp of when to make a next charge.
 */
function fundraiser_sustainers_get_next_charge_time(&$time = NULL, $context = array()) {
  if (is_null($time)) {
    $time = strtotime('now');
  }

  $next_charge = strtotime('+1 month', $time);
  // Allow other modules to adjust next_charge as needed.
  $time = $next_charge;
  drupal_alter('fundraiser_sustainers_recurring_next_charge', $next_charge, $context);
  return $next_charge;
}

/**
 * Add a single record to a sustainer series.
 *
 * @param mixed $donation
 *   Donation object from series.
 *
 * @param int $next_charge
 *   UNIX timestamp representing the date this order should be charged.
 */
function fundraiser_sustainers_add_order_to_series($donation, $next_charge) {
  $sustainer_key = fundraiser_sustainers_get_sustainer_key_value();
  $new_donation = clone $donation;
  $new_donation->sid = 0; // Not actually submitted, it's automated, so no sid.
  // Create the new donation object, but do not process it. Processing doesn't occur till cron.
  // New donation has all of the old donation information already loaded.
  fundraiser_donation_create($new_donation);
  fundraiser_donation_comment($new_donation, 'Sustainer donation scheduled to be charged at @next_charge',
    array('@next_charge' => format_date($next_charge)));
  // After this, the donation did and donation data is set.
  // The new donation object, with new did, needs to be saved to recurring so we can grab it later.
  $recurring_donation = array(
    'master_did' => $donation->recurring->master_did,
    'did' => $new_donation->did,
    'next_charge' => $next_charge,
    'sustainer_key' => $sustainer_key,
  );
  // Update the recurring table.
  _fundraiser_sustainers_create_recurring($recurring_donation);
  // Load the newly created individual donation into salesforce_donation.
  if (module_exists('salesforce_genmap')) {
    $sf_donation = fundraiser_donation_get_donation($new_donation->did, TRUE);
    salesforce_genmap_send_object_to_queue('salesforce_donation', 'insert',
      $sf_donation->node, $sf_donation->did, $sf_donation, 'donation');
  }
}

/**
 * Creates form to cancel donations.
 */
function fundraiser_sustainers_cancel_form($form, &$form_state, $donation) {
  // Only allow certain users to cancel future donations.
  $form['#access'] = user_access('cancel future donations');
  // Otherwise, provide cancel button.
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['reason'] = array(
    '#type' => 'textarea',
    '#title' => t('Reason'),
    '#default_value' => t('Please enter a brief description of why you are cancelling. ' .
      'This will help us better serve you in the future.'),
    '#maxlength' => 500,
    '#cols' => 70,
    '#rows' => 3,
    '#resizable' => FALSE,
    '#required' => TRUE,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel all future payments'),
  );
  $form['#donation'] = $donation;
  return $form;
}

/**
 * Form submit handler for cancel donations form.
 */
function fundraiser_sustainers_cancel_form_submit($form, &$form_state) {
  global $user;
  $master_did = $form_state['values']['master_did'];
  $reason = $form_state['values']['reason'];
  if (empty($reason) || $reason == t('Please enter a brief description of why you are cancelling. ' .
      'This will help us better serve you in the future.')) {
    $reason = t('No reason given.');
  }
  // Cancel the donations.
  $sustainer_donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($sustainer_donations as $sustainer_donation) {
    $donation = fundraiser_donation_get_donation($sustainer_donation->did);

    // Add the cancel reason to the donation's recurring object.
    $donation->recurring->cancellation_reason = $reason;

    // Cancel the donation.
    // @see fundraiser_sustainers_fundraiser_donation_cancel().
    fundraiser_donation_cancel($donation);

    // Add a watchdog entry with the did and reason.
    watchdog('fundraiser_sustainers', 'Donation cancelled for #@did. Reason: @reason',
      array('@did' => $donation->did, '@reason' => $reason));
  }

  drupal_set_message(t('All future payments cancelled.'));
}

/**
 * Implements hook_fundraiser_donation_get_donation().
 */
function fundraiser_sustainers_fundraiser_donation_get_donation($donation) {
  // Add recurring data to the fundraiser donation.
  $recurring = _fundraiser_sustainers_get_recurring_by_did($donation->did);
  if ($recurring) {
    $donation->recurring = $recurring;
    // Skip this for the master donation
    if (isset($donation->recurring->master_did) && $donation->recurring->master_did != $donation->did) {
      // Use the same submission information from the original donation.
      $master_donation = fundraiser_donation_get_donation($donation->recurring->master_did);
      if (isset($master_donation->submission_data)) {
        $donation->submission_data = $master_donation->submission_data;
      }
      $donation->sid = $master_donation->sid;
      $donation->master_did = $master_donation->did;
    }
    if (empty($donation->close_date)) {
      $donation->close_date = date('Y-m-d', $donation->recurring->next_charge);
    }
    $donation->donation['recurs_monthly'] = TRUE;
  }
  else {
    $donation->donation['recurs_monthly'] = FALSE;
  }
}

/**
 * Implements hook_fundraiser_donation_create().
 */
function fundraiser_sustainers_fundraiser_donation_create($donation) {
  // If this has been flagged as a recurring donation, mark it properly so all following systems can understand.
  $recurs = FALSE;
  if (!isset($donation->donation['recurs_monthly'])) { // In case the recurs_monthly field doesn't exist.
    $donation->donation['recurs_monthly'] = FALSE;
  }
  if (is_bool($donation->donation['recurs_monthly'])) {
    $recurs = $donation->donation['recurs_monthly'];
  }
  elseif (is_array($donation->donation['recurs_monthly']) && isset($donation->donation['recurs_monthly'][0])) {
    $recurs = ($donation->donation['recurs_monthly'][0] == 'recurs') ? TRUE : FALSE;
  }
  else {
    $recurs = ($donation->donation['recurs_monthly'] == 'recurs') ? TRUE : FALSE;
  }
  // Set the value for the donation.
  $donation->donation['recurs_monthly'] = $recurs;
}

/**
 * Implements hook_fundraiser_donation_success().
 */
function fundraiser_sustainers_fundraiser_donation_success($donation) {
  // If we don't have a master id already set, check if this is a new recurring order.
  if (!isset($donation->recurring->master_did)) {
    // If this is in fact a recurring donation, then we act.
    if ($donation->donation['recurs_monthly'] == TRUE) {
      $info = _fundraiser_get_donation_gateway($donation->did);
      if (_fundraiser_sustainers_supports_recurring($info['allow_recurring'], $donation->donation['payment_method'])) { // Allows recurring
        // Then we do all the creating of offline values, table, SF object, and extra orders.
        $donation->recurring = new stdClass();
        $donation->recurring->master_did = $donation->did;
        // Add the master to the recurring table.
        $recurring_donation = array(
          'did' => $donation->did,
          'master_did' => $donation->did,
          'next_charge' => strtotime('now'),
          'gateway_resp' => 'success',
          'attempts' => 1,
        );
        // Update the recurring table.
        _fundraiser_sustainers_create_recurring($recurring_donation);
        // Now handle the recurring object, and the rest of the orders.
        if (!_fundraiser_sustainers_offsite_recurring($info['offsite_recurring'], $donation->donation['payment_method'])) { // Is not an offline recurring
          // Load the newly created recurring donation into salesforce.
          if (module_exists('salesforce_genmap')) {
            $sf_donation = fundraiser_donation_get_donation($donation->did, TRUE);
            salesforce_genmap_send_object_to_queue('fundraiser_sustainers', 'insert',
              $sf_donation->node, $sf_donation->did, $sf_donation, 'recurring_donation');
          }
          $info = _fundraiser_get_donation_gateway($donation->did);
          // This created donation is the master, so passing it in to create the set.
          // We can't predict the form key for these values, so ask the gateway to provide.
          if (isset($info['expire callback'])) {
            $expiration_func = $info['expire callback'];
            if (function_exists($expiration_func)) {
              $expires = $expiration_func($donation->donation, $info);
              if (isset($expires['month']) && isset($expires['year'])) {
                _fundraiser_sustainers_create_future_orders($donation, $expires['month'], $expires['year']);
              }
            }
          }
        }
        else {
          // ALERT: This gateway does it's own recurring stuff, so we skipped it here.
          // But we should probably tell someone this was attempted.
          watchdog('fundraiser_sustainers', 'A offsite recurring donation was created, for master donation id #@nid',
            array('@nid' => $donation->nid));
        }
      }
      else {
        // ALERT: This gateway does not support recurring stuff, so we skipped it here.
        // But we should probably tell someone this was attempted. We have protections on the form, but they
        // are JS based to hide the form element, so we check server side too.
        watchdog('fundraiser_sustainers', 'A recurring donation for a non-recurring gateway was attempted, for master donation id #@nid',
          array('@nid' => $donation->nid));
      }
    }
  }
  else {
    // And update the sustainer table.
    db_query('UPDATE {fundraiser_sustainers} SET ' .
      'gateway_resp = \'success\', attempts = attempts + 1 ' .
      'WHERE did = :did', array(':did' => $donation->did)
    );
    // For all recurring when processed, check if we need to send a notice about the set almost done.
    if (_fundraiser_sustainers_count_donations_recurr_remaining($donation->recurring->master_did) == 1) {
      _fundraiser_sustainers_send_cc_notification($donation->recurring->master_did, $donation->uid);
    }
  }
}

/**
 * Implements hook_fundraiser_donation_decline().
 */
function fundraiser_sustainers_fundraiser_donation_decline($donation) {
  if ($donation->donation['recurs_monthly'] == TRUE) {
    // Update data internal to fundraiser. TODO move this db stuff.
    db_query('UPDATE {fundraiser_sustainers} SET ' .
      'gateway_resp = \'failed\', attempts = attempts + 1, ' .
      'lock_id = 0, ' .
      'next_charge = unix_timestamp(timestampadd(DAY, 1, from_unixtime(next_charge))) ' .
      'WHERE did = :did', array(':did' => $donation->did)
    );
    // Get the number of times this order has been attempted
    $attempt_count = db_query('SELECT attempts FROM {fundraiser_sustainers} WHERE did = :did',
      array(':did' => $donation->did))->fetchColumn();

    if ($attempt_count == 3) {
      // Final attempt, add debug alert.

    // update sf queue.
    if (module_exists('salesforce_genmap')) {
      $stages = variable_get('salesforce_donation_mapped_stages', salesforce_donation_default_stage_map());
      foreach ($stages as $salesforce_name => $commerce_name) {
        if ($commerce_name == 'failed') {
           $stage = $salesforce_name;
        }
      }
      if (isset($stage)) {
        $donation->recurring->sf_stagename = $stage;
        // If a failed stage is mapped, re-queue the failed transaction for export.
        salesforce_genmap_send_object_to_queue('salesforce_donation', 'update', $donation->node, $donation->did, $donation, 'donation');
      }
      else {
        $donation->recurring->sf_stagename = 'Donation failed, but stage could not be mapped.';
        watchdog('fundraiser_sustainers', 'Sustainer payment failure for donation @id will not be exported
          to Salesforce because the failed order status has not been mapped to an appropriate Opportunity stage. If you wish to export failed sustainer payments you need to add a failed stage in Salesforce and map it on the Salesforce donation settings page.', array('@id' => $donation->did), WATCHDOG_DEBUG, l('Salesforce donation settings', 'admin/config/salesforce/salesforce-donation'));
      }

    }
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed 3 times. ' .
        'The donation will not be submitted for payment again. Gateway message: @message',
        array('@id' => $donation->did, '@message' => $donation->result['message']), WATCHDOG_DEBUG);
    }
    else {
      // Log this failure
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed @attempts times. It will be processed again in 1 day. Gateway message: @message',
        array('@id' => $donation->did, '@attempts' => $attempt_count, '@message' => $donation->result['message']), WATCHDOG_DEBUG);
    }
  }
}

/**
 * Implements hook_fundraiser_donation_cancel().
 */
function fundraiser_sustainers_fundraiser_donation_cancel($donation) {
  // Set the reason value if one has been set on the donation's recurring object.
  $reason = '';
  if (!empty($donation->recurring->cancellation_reason)) {
    $reason = $donation->recurring->cancellation_reason;
  }

  // Set the gateway resp field to canceled.
  db_update('fundraiser_sustainers')
    ->fields(array('gateway_resp' => 'canceled', 'cancellation_reason' => $reason))
    ->condition('did', $donation->did)
    ->execute();
}

/**
 * Matches the current site against the value in the sustainer key file.
 *
 * @return
 *    TRUE when run on a site matching the sustainer key value, otherwise FALSE.
 */
function fundraiser_sustainers_processor_key_match() {
  static $key;

  // Construct a site string to match the key against
  $site = trim($_SERVER['HTTP_HOST']) . rtrim(base_path(), '/');

  if (!empty($key)) {
    return $key == $site;
  }

  // This is to check that we have everything configured for safe charging.
  // If not, we should throw an issue about it and not try to process stuff.
  // This value is normally set in the glue module for payment.
  // Get the key and see if it matches the server's host.
  $key = fundraiser_sustainers_get_sustainer_key_value();
  if ($key == $site) {
    return TRUE;
  }

  // If we get here key is no good.
  return FALSE;
}

/**
 * Attempts to open and read the contents of the sustainer key file.
 */
function fundraiser_sustainers_get_sustainer_key_value() {
  static $value; // Cache per page load.
  if (empty($value)) {
    $value = FALSE;
    $filename = fundraiser_sustainers_sustainer_key_file_exists();
    if ($filename && $file = fopen($filename, 'r')) {
      $filesize = filesize($filename);
      if ($filesize > 0) {
        $value = trim(fread($file, $filesize));
        fclose($file);
      }
      else {
        watchdog('fundraiser_sustainers', 'Unable to read the contents of the sustainer key file @file.', array('@file' => $filename), WATCHDOG_CRITICAL);
      }
    }
    else {
      watchdog('fundraiser_sustainers', 'Unable to get the value of the sustainer key file because the file does not exist.', NULL, WATCHDOG_CRITICAL);
    }
  }
  // Return FALSE or the actual value of the key file.
  return $value;
}

/**
 * Determines if the sustainer key file exists in the file system.
 *
 * @return
 *   The filename of of the sustainer key file or FALSE if it doesn't
 *   exist.
 */
function fundraiser_sustainers_sustainer_key_file_exists() {
  $dir = module_invoke_all('fundraiser_get_credit_encryption_path');
  $dir = $dir[0];
  if (!empty($dir) && $dir !== t('Not configured, see below.')) {
    $filename = rtrim($dir, '/\\') . '/sustainer.key';
    if (file_exists($filename) && $file = fopen($filename, 'r')) {
      return $filename;
    }
  }

  return FALSE;
}

/**
 * Helper function, kicks off an email to a sustainer to remind them their credit card is about to expire.
 */
function _fundraiser_sustainers_send_cc_notification($master_did, $uid) {
  // Short circuit this email if the configuration for fundraiser says don't send it.
  if (!variable_get('fundraiser_sustainers_send_email', TRUE)) {
    return;
  }
  // Otherwise, send it.
  $user = user_load($uid);
  // Load the last remaining order so we can get some info for the email.
  $did = db_query('SELECT did FROM {fundraiser_sustainers} WHERE master_did = :master_did AND gateway_resp IS NULL LIMIT 0,1', // Coder: this is ok.
    array(':master_did' => $master_did))->fetchColumn();
  $donation = fundraiser_donation_get_donation($did);
  // Do token replacement on body.
  $body = variable_get('fundraiser_cc_exp_body',
    'Your card ending in [donation:card_number] is about to expire on [donation:card_expiration_month]/[donation:card_expiration_year].');
  $token_set = array(
    'node' => $donation->node,
    'donation' => $donation,
    'user' => $user,
  );
  $body = token_replace($body, $token_set);
  // Pass tokens as param so hook_mail has access.
  $params['fundraiser_sustainers_token_set'] = $token_set;
  $params['fundraiser_sustainers_body'] = $body;
  watchdog('fundraiser_sustainers', 'Credit card expiration email sent to @mail', array('@mail' => $user->mail), WATCHDOG_INFO);
  drupal_mail('fundraiser_sustainers', 'fundraiser_cc_notification', $user->mail, user_preferred_language($user), $params);
}

/**
 * Helper function, given a gateway determine if the gateway supports recurring donations.
 */
function _fundraiser_sustainers_supports_recurring($allow_recurring, $payment_method) {
  if (isset($allow_recurring) && !empty($allow_recurring) && in_array($payment_method, $allow_recurring)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function, given a gateway determine if the gateway supports recurring donations.
 */
function _fundraiser_sustainers_offsite_recurring($offsite_recurring, $payment_method) {
  if (isset($offsite_recurring) && !empty($offsite_recurring) && in_array($payment_method, $offsite_recurring)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Database functions.
 */

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_create_recurring($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    $record = $donation;
    drupal_write_record('fundraiser_sustainers', $record);
  }
  else {
    _fundraiser_sustainers_update_recurring($donation);
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_get_recurring_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_sustainers} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_update_recurring($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    _fundraiser_sustainers_create_recurring($donation);
  }
  else {
    $record = array_merge((array) $donation_data, $donation); // Merge data together so we get everything in the record.
    drupal_write_record('fundraiser_sustainers', $record, 'did');
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_delete_recurring($did) {
  db_delete('fundraiser_sustainers')->condition('did', $did)->execute();
}

/**
 * DB funct, get user donation set information that are recurring.
 */
function _fundraiser_sustainers_get_donation_sets_recurr_by_uid($uid) {
  $donation_sets = db_query('SELECT r.master_did, MIN(r.next_charge) AS start_date, ' .
    'MAX(r.next_charge) AS expire_date FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE d.uid = :uid ' .
    'GROUP BY r.master_did ' .
    'ORDER BY r.master_did DESC', array(':uid' => $uid))->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_did);
    if (isset($next_charge->next_charge)) {
      $donation_sets[$index]->next_charge = $next_charge->next_charge;
      $donation_sets[$index]->status = empty($next_charge->cancellation_reason) ? t('Active') : t('Cancelled');
    }
    else {
      $donation_sets[$index]->next_charge = '';
      $donation_sets[$index]->status = t('No next charge');
    }
  }
  return $donation_sets;
}

/**
 * DB funct, get user donation set information that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donation_sets() {
  $donation_sets = db_query('SELECT r.master_did, MIN(r.next_charge) AS start_date, ' .
    'MAX(r.next_charge) AS expire_date FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = r.did ' .
    'GROUP BY r.master_did ' .
    'ORDER BY r.master_did DESC')->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_did);
    if (isset($next_charge->did)) {
      $donation_sets[$index]->next_charge = $next_charge->next_charge;
      $donation_sets[$index]->status = empty($next_charge->cancellation_reason) ? t('active') : t('cancelled');
    }
  }
  return $donation_sets;
}


/**
 * DB funct, get order donations that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donations_recurr_by_member($did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE d.did = :did OR r.master_did = :master_did ' .
    'ORDER BY r.next_charge ASC', array(':did' => $did, ':master_did' => $did))->fetchAll();
  return $donations;
}

/**
 * DB func, get the next charge date for a donation set.
 */
function _fundraiser_sustainers_get_donations_next_charge($master_did) {
  $now = strtotime('now');
  return db_query('SELECT * FROM {fundraiser_sustainers} ' .
    'WHERE master_did = :master_did ' .
    'AND next_charge > :now ' .
    'ORDER BY next_charge ASC ' .
    'LIMIT 0, 1',
    array(':master_did' => $master_did, ':now' => $now))->fetchObject();
}

/**
 * Get last charge date for a donation set.
 */
function _fundraiser_sustainers_get_donations_last_charge($master_did) {
  $now = strtotime('now');
  return db_query('SELECT * FROM {fundraiser_sustainers} ' .
    'WHERE master_did = :master_did ' .
    'AND next_charge > :now ' .
    'ORDER BY next_charge DESC ' .
    'LIMIT 0, 1',
    array(':master_did' => $master_did, ':now' => $now))->fetchObject();
}

/**
 * DB funct, get order donations that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donations_recurr_by_masterdid($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are remaining.
 */
function _fundraiser_sustainers_count_donations_recurr_remaining($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  $count = 0;
  foreach ($donations as $donation) {
    $count++;
  }
  return $count;
}

/**
 * DB funct, get order donation sets that are remaining.
 */
function _fundraiser_sustainers_get_donations_recurr_remaining($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'AND (r.gateway_resp IS NULL OR (r.gateway_resp = \'failed\' && r.attempts != 3)) ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are processed.
 */
function _fundraiser_sustainers_count_donations_recurr_processed($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_processed($master_did);
  if ($donations) {
    return count($donations);
  }
  return 0;
}

/**
 * DB funct, get order donation sets that are processed.
 */
function _fundraiser_sustainers_get_donations_recurr_processed($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'AND r.gateway_resp = \'success\' ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * Counts the number of sustainers in a sustainer series, including the master.
 *
 * @param int $master_did
 *   The donation ID of the master donation.
 *
 * @return int
 *   Number of sustainer rows with the given master donation ID.
 */
function fundraiser_sustainers_count_donations_in_series($master_did) {
  return db_query('SELECT COUNT(*) FROM {fundraiser_sustainers}
    WHERE master_did = :did', array(':did' => $master_did))->fetchField();
}

/**
 * DB function, get unlocked donations ready to be processed.
 * Lock them.
 */
function _fundraiser_sustainers_cron_get_recurring($limit = 1000) {
  $now = strtotime('now');
  $uni_batch_id = uniqid();
  // Lock them (faster to lock, then query, than the other way around).
  // Since large data set returns => delay.
  $donations = db_query('SELECT r.did FROM {fundraiser_sustainers} r ' .
    'WHERE (r.gateway_resp IS NULL OR r.gateway_resp = \'failed\') ' .
    'AND r.next_charge < :now ' .
    'AND (r.attempts < 3 OR r.attempts IS NULL) ' . // If already been tried 3 times, Stop Trying.
    'AND r.lock_id = 0 ' . // And not locked.
    'LIMIT 0, ' . $limit,
    array(':now' => $now)
  )->fetchAllKeyed(0, 0);
  if (!empty($donations)) {
    db_query('UPDATE {fundraiser_sustainers} r1 ' .
      'SET r1.lock_id = :uni_batch_id ' .
      'WHERE r1.did IN (:donations)',
      array(':uni_batch_id' => $uni_batch_id, ':donations' => $donations)
    );
  }
  // Grab the locked donations for this batch.
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.lock_id = :uni_batch_id ' . // Locked to this unique ID.
    'ORDER BY r.next_charge ASC',
    array(':uni_batch_id' => $uni_batch_id))->fetchAll();
  // Return them.
  return $donations;
}

/**
 * Get total sustainer count by wdonation form node id.
 * @param int $nid
 *
 * @return
 * Count of distinct sustainer series for this donation form
 */
function _fundraiser_sustainers_get_total_sustainers_by_nid($nid, $start = FALSE, $end = FALSE) {
  static $data = array();
  if (module_exists('fundraiser_commerce')) {
    if (empty($data[$nid])) {
      // SELECT COUNT(DISTINCT(s.master_did))
      // FROM fundraiser_sustainers s
      // JOIN fundraiser_donations d
      //   ON s.master_did = d.did
      // JOIN commerce_orders c         // optional
      //   ON c.order_id = s.master_did // optional
      // WHERE d.nid = :nid
      //   AND o.created >= :start      // optional
      //   AND 0.created >= :end;       // optional
      $query = db_select('fundraiser_sustainers', 's');
      $query->join('fundraiser_donation', 'd', 'd.did = s.master_did');
      if ($start || $end) {
        $query->join('commerce_order', 'o', 'o.order_id = s.master_did');
      }
      $query->addExpression('COUNT(DISTINCT(s.master_did))', 'count');
      $query->condition('d.nid', $nid, '=');
      // add conditionals for start/end date
      if ($start) {
        $query->condition('o.created', $start, '>=');
      }
      if ($end) {
        $query->condition('o.created', $end, '<=');
      }
      $data[$nid] = $query->execute()->fetchField();
    }
    return $data[$nid];
  }

  // TODO: add accompanying query for fundraiser_ubercart
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_create_sustainers_node($sustainers_node) {
  $sustainers_node = (array) $sustainers_node;
  $sustainers_node_data = FALSE;
  if (isset($sustainers_node['nid'])) {
    $sustainers_node_data = _fundraiser_sustainers_get_sustainers_node_by_nid($sustainers_node['nid']);
  }
  if (!$sustainers_node_data) {
    drupal_write_record('fundraiser_sustainers_nodes', $sustainers_node);
  }
  else {
    _fundraiser_sustainers_update_sustainers_node($sustainers_node);
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_get_sustainers_node_by_nid($nid) {
  return db_query('SELECT * FROM {fundraiser_sustainers_nodes} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_update_sustainers_node($sustainers_node) {
  $sustainers_node = (array) $sustainers_node;
  $sustainers_node_data = FALSE;
  if (isset($sustainers_node['nid'])) {
    $sustainers_node_data = _fundraiser_sustainers_get_sustainers_node_by_nid($sustainers_node['nid']);
  }
  if (!$sustainers_node_data) {
    _fundraiser_sustainers_create_sustainers_node($sustainers_node);
  }
  else {
    $sustainers_node = array_merge((array) $sustainers_node_data, $sustainers_node);
    drupal_write_record('fundraiser_sustainers_nodes', $sustainers_node, 'nid');
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers_sustainers_node.
 */
function _fundraiser_sustainers_delete_sustainers_node($nid) {
  db_delete('fundraiser_sustainers_nodes')->condition('nid', $nid)->execute();
}

/**
 * Returns the cid of the recurring webform component for a given node.
 *
 * @param object $node
 *   Node object.
 *
 * @return bool|int
 *   The component ID, or FALSE if one can't be found.
 */
function fundraiser_sustainers_get_recurring_cid_by_node($node) {
  $form_key = 'recurs_monthly';

  if (count($node->webform['components'])) {
    foreach ($node->webform['components'] as $cid => $component) {
      if ($component['form_key'] == $form_key) {
        return $cid;
      }
    }
  }

  return FALSE;
}

/**
 * Determine if the webform component value indicates that a submission is recurring.
 *
 * @param string|array $value
 *   The value of the recurring webform component to check.
 *
 * @return bool
 *   TRUE if this value indicates the submission is recurring.
 */
function fundraiser_sustainers_component_value_is_recurring($value) {
  $recurs_string = 'recurs';

  // The component is usually a select or checkbox.
  // So $value would be an array.
  if (is_array($value) && in_array($recurs_string, $value)) {
    return TRUE;
  }
  // If recurring is required, the component will be hidden.
  // And $recurring_value will be a string.
  elseif (is_string($value) && $value == $recurs_string) {
    return TRUE;
  }

  return FALSE;
}
